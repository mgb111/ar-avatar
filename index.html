<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Avatar Lip-Sync & AR</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            background-color: #111827;
            color: #f3f4f6;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #ui-container {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            background: linear-gradient(to top, rgba(17, 24, 39, 0.9), rgba(17, 24, 39, 0));
        }
        #ar-button {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background-color: rgba(31, 41, 55, 0.8);
            color: white;
            padding: 0.75rem 1.25rem;
            border-radius: 9999px;
            border: 1px solid rgba(75, 85, 99, 0.8);
            cursor: pointer;
            font-weight: 600;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: all 0.2s ease-in-out;
        }
        #ar-button:hover {
            background-color: rgba(55, 65, 81, 0.9);
        }
        #ar-button:active {
            transform: scale(0.95);
        }
        #loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(17, 24, 39, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            color: #d1d5db;
            font-size: 1.125rem;
        }
        .loader {
            border: 4px solid #4b5563;
            border-top: 4px solid #60a5fa;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-right: 1rem;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Style for file input */
        input[type="file"]::file-selector-button {
            background-color: #3b82f6;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        input[type="file"]::file-selector-button:hover {
            background-color: #2563eb;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="loading-overlay">
        <div class="loader"></div>
        <span>Loading 3D environment...</span>
    </div>

    <div id="ui-container" class="max-w-4xl mx-auto w-full">
        <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
            <div class="flex flex-col gap-2">
                <label for="avatar-upload" class="text-sm font-medium text-gray-300">1. Load GLB Avatar</label>
                <input id="avatar-upload" type="file" accept=".glb" class="block w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-blue-600 file:text-white hover:file:bg-blue-700">
            </div>
            <div class="flex flex-col gap-2">
                <label for="script-input" class="text-sm font-medium text-gray-300">2. Enter Script</label>
                <textarea id="script-input" rows="2" class="block w-full rounded-lg border-gray-600 bg-gray-800 text-gray-200 shadow-sm focus:border-blue-500 focus:ring-blue-500 p-2" placeholder="Hello, welcome to the future!"></textarea>
            </div>
        </div>
        <button id="speak-button" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 shadow-lg">
            Speak & Animate
        </button>
    </div>

    <!-- ES Module Shims for older browser support -->
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { ARButton } from 'three/addons/webxr/ARButton.js';

        let camera, scene, renderer, controls;
        let model, mixer, clock;
        let jawOpenMorphTargetIndex = null;
        let reticle;
        let voices = [];
        
        const loadingOverlay = document.getElementById('loading-overlay');
        const speakButton = document.getElementById('speak-button');
        const scriptInput = document.getElementById('script-input');
        const avatarUpload = document.getElementById('avatar-upload');

        const defaultAvatarUrl = 'https://raw.githubusercontent.com/mgb111/ar-avatar/main/avatar.glb';

        init();

        function init() {
            // Scene Setup
            scene = new THREE.Scene();
            clock = new THREE.Clock();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 2.5);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2.5);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 1, 0);
            controls.update();

            // Load Default Model
            loadModel(defaultAvatarUrl);

            // Event Listeners
            avatarUpload.addEventListener('change', handleAvatarUpload);
            speakButton.addEventListener('click', speak);
            window.addEventListener('resize', onWindowResize);
            
            // Augmented Reality Setup
            setupAR();

            // Pre-load voices
            populateVoiceList();
            if (speechSynthesis.onvoiceschanged !== undefined) {
                speechSynthesis.onvoiceschanged = populateVoiceList;
            }

            // Start Animation Loop
            renderer.setAnimationLoop(animate);
        }

        function populateVoiceList() {
            voices = window.speechSynthesis.getVoices();
        }

        function setupAR() {
            const arButton = ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] });
            arButton.id = 'ar-button';
            arButton.textContent = "Enter Augmented Reality"
            document.body.appendChild(arButton);

            // Reticle for placing object
            reticle = new THREE.Mesh(
                new THREE.RingGeometry(0.05, 0.07, 32).rotateX(-Math.PI / 2),
                new THREE.MeshBasicMaterial()
            );
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);

            let controller = renderer.xr.getController(0);
            controller.addEventListener('select', onSelect);
            scene.add(controller);
        }

        function onSelect() {
            if (reticle.visible && model) {
                model.position.setFromMatrixPosition(reticle.matrix);
                model.visible = true;
            }
        }
        
        let hitTestSource = null;
        let hitTestSourceRequested = false;

        function animate(timestamp, frame) {
            controls.update();
            if (mixer) mixer.update(clock.getDelta());
            
            // Handle Lip Sync
            handleLipSync();
            
            // Handle Augmented Reality Hit Test
            if (frame) {
                const referenceSpace = renderer.xr.getReferenceSpace();
                const session = renderer.xr.getSession();

                if (hitTestSourceRequested === false) {
                    session.requestReferenceSpace('viewer').then(referenceSpace => {
                        session.requestHitTestSource({ space: referenceSpace }).then(source => {
                            hitTestSource = source;
                        });
                    });
                    session.addEventListener('end', () => {
                        hitTestSourceRequested = false;
                        hitTestSource = null;
                        reticle.visible = false;
                        // Reset model position after exiting AR
                        if(model) {
                           model.position.set(0, 0, 0);
                           model.visible = true;
                        }
                    });
                    hitTestSourceRequested = true;
                }

                if (hitTestSource) {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);
                    if (hitTestResults.length) {
                        const hit = hitTestResults[0];
                        reticle.visible = true;
                        reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
                        if (model && model.visible === false) {
                           // Prompt user to tap
                        }
                    } else {
                        reticle.visible = false;
                    }
                }
            }

            renderer.render(scene, camera);
        }

        function handleAvatarUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const url = URL.createObjectURL(file);
                loadModel(url, () => URL.revokeObjectURL(url));
            }
        }

        function loadModel(url, onLoadedCallback = () => {}) {
            loadingOverlay.style.display = 'flex';
            const loader = new GLTFLoader();
            
            // Clean up previous model
            if(model) {
                scene.remove(model);
                model = null;
                jawOpenMorphTargetIndex = null;
            }

            loader.load(url, (gltf) => {
                model = gltf.scene;
                
                // Center and scale model
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 2.0 / maxDim; // Scale to be ~2 meters tall
                model.scale.set(scale, scale, scale);
                model.position.sub(center.multiplyScalar(scale));
                
                scene.add(model);

                // Find jaw morph target
                model.traverse((node) => {
                    if (node.isMesh && node.morphTargetDictionary) {
                        // Common names for jaw/mouth open morph targets
                        const possibleNames = ['jawOpen', 'mouthOpen', 'v_jaw_open', 'mouth_open'];
                        for (const name of possibleNames) {
                            if (node.morphTargetDictionary[name] !== undefined) {
                                jawOpenMorphTargetIndex = node.morphTargetDictionary[name];
                                break;
                            }
                        }
                    }
                });

                // Animation Mixer
                if (gltf.animations && gltf.animations.length) {
                    mixer = new THREE.AnimationMixer(model);
                    // Play a default idle animation if available
                    const idleAction = mixer.clipAction(gltf.animations.find(clip => clip.name.toLowerCase().includes('idle')) || gltf.animations[0]);
                    idleAction.play();
                }
                
                loadingOverlay.style.display = 'none';
                if (renderer.xr.isPresenting) {
                   model.visible = false;
                   reticle.visible = true;
                } else {
                   model.visible = true;
                }

                onLoadedCallback();
            }, 
            // onProgress callback (optional)
            undefined, 
            (error) => {
                console.error(error);
                loadingOverlay.innerHTML = '<span>Error loading model. Please try another one.</span>';
            });
        }
        
        function speak() {
            const text = scriptInput.value;
            if (!text || !model) {
                return;
            }

            if (jawOpenMorphTargetIndex === null) {
                console.warn("Could not find a 'jawOpen' or similar mouth shape on this avatar. Lip-sync is disabled.");
            }
            
            // Stop any currently playing speech
            window.speechSynthesis.cancel();

            const utterance = new SpeechSynthesisUtterance(text);

            // Find a male voice
            const maleVoice = voices.find(voice => 
                voice.lang.startsWith('en') && 
                (voice.name.includes('Male') || voice.name.includes('Google US English') || voice.name.includes('David'))
            );

            if (maleVoice) {
                utterance.voice = maleVoice;
            } else {
                console.warn("Male voice not found, using default.");
            }

            window.speechSynthesis.speak(utterance);
        }

        function handleLipSync() {
            if (window.speechSynthesis.speaking && jawOpenMorphTargetIndex !== null) {
                const now = Date.now();
                const influence = (Math.sin(now * 0.025) + 1) / 2; // Simple sine wave for mouth movement
                model.traverse(child => {
                    if (child.isMesh && child.morphTargetInfluences) {
                        child.morphTargetInfluences[jawOpenMorphTargetIndex] = influence * 0.8; // Don't open full
                    }
                });
            } else if (model && jawOpenMorphTargetIndex !== null) {
                // Reset when not speaking
                model.traverse(child => {
                    if (child.isMesh && child.morphTargetInfluences) {
                        child.morphTargetInfluences[jawOpenMorphTargetIndex] = 0;
                    }
                });
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

    </script>
</body>
</html>



